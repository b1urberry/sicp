;;Derivative using data-directed programming (DDP)

(load "helpers.scm")
(define (deriv expression var)
	(install-sum-pkg)
	;;expressions as single number or variable are not lists and cannot be generalized using the (operator operands) format
  (cond ((number? expression) 0)
        ((variable? expression) (if (same-variable? expression var) 1 0))
        ;;apply corresponding deriv procedures to 
     		(else ((get 'deriv (operator expression)) (operands expression)
     																							var))))
(define (variable? x) (symbol? x))
(define (not-number? x) (not (number? x)))
(define (same-variable? x y) (eq? x y))
(define (operator expression) (car expression))
(define (operands expression) (cdr expression))

(define (install-sum-pkg)
  (define (make-sum . items)
  	(let ((sum-num (accumulate + 0 (filter number? items)))
  				(terms (filter not-number? items)))
    		(cond ((null? terms) sum-num)
    	  	    ((= 0 sum-num) (cons '+ terms))
    	    		(else (cons '+ (append terms (list sum-num)))))))
	(define (deriv-sum . expressions var)
	  (make-sum (map (lambda (expression) (deriv expression var)) expressions)))
	(put 'deriv '+ deriv-sum))

(define (isntall-product-pkg)
	(define (make-sum . items)
  	(let ((sum-num (accumulate + 0 (filter number? items)))
  				(terms (filter not-number? items)))
    		(cond ((null? terms) sum-num)
    	  	    ((= 0 sum-num) (cons '+ terms))
    	    		(else (cons '+ (append terms (list sum-num)))))))
	(define (make-product . items)
	  (cond ((null? (cdr items)) (car items))
	        (else ((let ((product-num (accumulate * 1 (filter number? items)))
	  									 (terms (filter not-number? items)))
							   	 (cond ((null? terms) product-num)
							   	       ((= 0 product-num) 0)
							   	       ((= 1 product-num) (cons '* terms))
							   	     	 (else (cons '* (append terms (list product-num))))))))))
	(define (deriv-product . expressions var)
	  (let ((multiplier (car expressions))
	  			(multiplicands (make-product (cdr expressions))))
	  	(make-sum (make-product (deriv multiplier var)
	  													multiplicands)
	  						(make-product (deriv multiplicands var)
	  													multiplier)))))